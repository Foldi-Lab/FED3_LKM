#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Sep 22 16:23:40 2021

@author: lauramilton
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon May 17 13:27:16 2021

@author: lauramilton
"""

time_column = 'MM:DD:YYYY hh:mm:ss'
event_column = 'Event'
session_type_column = 'Session_type'
left_poke_column = 'Left_Poke_Count'
right_poke_column = 'Right_Poke_Count'
pellet_count_column = 'Pellet_Count'
retrieval_time_column = 'Retrieval_Time'
poke_time_column = 'Poke_Time'

session_duration_mins = '180'
seconds_in_bins = '1800' # Enter how long you want the time bins to be in seconds; if not using bins enter '' which will give duration in seconds
initiation_poke = True

num_of_bins = int(session_duration_mins) / (int(seconds_in_bins) / 60)

export_results = 'N'
export_overview = 'N'

# Enter the FED import folder, FED export folder, cohort/experiment export folder and the FED number

import_location = r'/Volumes/shared/MNHS-SOBS-Physiology/Foldi-Group/FED3 data/PSI New Rev 220211/FR1Both/'
export_location = r'/Volumes/shared/MNHS-SOBS-Physiology/Foldi-Group/FED3 data/PSI New Rev 220211/FR1Both/'
cohort_export_location = r'/Volumes/shared/MNHS-SOBS-Physiology/Foldi-Group/FED3 data/PSI New Rev 220211/FR1Both/Cohort/'


#-----------------------------------------------------------------------------

# Import the revelant data: time, FR ratio, active port, left poke, right poke, and pellet count.

import pandas as pd
import numpy as np
import os
import openpyxl

#-----
for folder in sorted(os.listdir(import_location)):
    if folder.startswith('FED'):
        s_date = []
        s_filename = []
        s_totalpokes = []
        s_leftpokes = []
        s_leftpercent = []
        s_rightpokes = []
        s_rightpercent = []
        s_pellets = []

        for filename in sorted(os.listdir(os.path.join(import_location, folder))):
            if filename.endswith('.CSV'):
                if '012522' in filename or '012622' in filename or '012722' in filename:
                        print(filename)
                        # Import the data
                        
                        import_name = filename
                        import_destination = import_location + folder + '/' + import_name
                        export_name = folder + ' FR1 both ' + import_name.strip('.CSV') + '.xlsx'
                        export_destination = export_location + folder + '/' + export_name
                        
                
                #-----
                
                        df = pd.read_csv(import_destination)
                        
                        time = df[time_column].tolist()
                        session_type = df[session_type_column].tolist()
                        event = df[event_column].tolist()
                        left_poke = df[left_poke_column].tolist()
                        right_poke = df[right_poke_column].tolist()
                        pellet_count = df[pellet_count_column].tolist()
                        retrieval_time = df[retrieval_time_column].tolist()
                        poke_time = df[poke_time_column].tolist()
                        
                        # Change the time column from strings to datetime format for calculating durations between timestamps and creating time bins
                        
                        import datetime as dt
                        
                        time_list = [dt.datetime.strptime(time, '%m/%d/%Y %H:%M:%S') for time in time]
                        
                        # Determine session start time which is the first timestamp generated by our poke to the/an acitve port to deliver a pellet
                        
                        session_start = time_list[0]
                        
                        # Remove the initiation poke/s and pellet data (if required)
                        
                        if initiation_poke == True:
                        
                            left_count = left_poke[0]
                            right_count = right_poke[0]
                            
                            del time[:2]
                            del session_type[:2]
                            del event[:2]
                            del left_poke[:2]
                            del right_poke[:2]
                            del pellet_count[:2]
                            del retrieval_time[:2]
                            del poke_time[:2]
                            
                            # Subtract the poke and pellet from the subsequent cumulative data
                            
                            left_poke_shifted = []
                            right_poke_shifted = []
                            pellet_count_shifted = []
                            
                            for i in range(0, len(left_poke)):
                                left_poke_shifted.append(left_poke[i] - left_count)
                                right_poke_shifted.append(right_poke[i] - right_count)
                                pellet_count_shifted.append(pellet_count[i] - 1)
                                    
                            # Shift the retrieval_time and pellet_count lists one step backwards so that the count/time is in the same index as the corresponding poke
                
                            retrieval_time.pop(0)
                            pellet_count_shifted.pop(0)
                            
                            # Add in a value to the end of each list to maintain list length so as not to lose the last row of other data
                            # for pellet_count this is a duplicate of preceding row, for retrieval_time this is np.nan
                            
                            retrieval_time.append(np.nan)
                            pellet_count_shifted.append((pellet_count[-1] - 1))

                            
                            # Create new lists that only include data from the lines where event == 'Poke'
                            time2 = []
                            session_type2 = []
                            event2 = []
                            left_poke2 = []
                            right_poke2 = []
                            pellet_count2 = []
                            retrieval_time2 = []
                            poke_time2 = []
                            
                            for a, b, c, d, e, f, g, h in zip(event, left_poke_shifted, right_poke_shifted, pellet_count_shifted, time, session_type, retrieval_time, poke_time):
                                if a != 'Pellet':
                                    event2.append(a)
                                    left_poke2.append(b)
                                    right_poke2.append(c) 
                                    pellet_count2.append(d)
                                    time2.append(e)
                                    session_type2.append(f)
                                    retrieval_time2.append(g)
                                    poke_time2.append(h)
                        else:
                            # Shift the retrieval_time and pellet_count lists one step backwards so that the count/time is in the same index as the corresponding poke
                
                            retrieval_time.pop(0)
                            pellet_count_shifted.pop(0)
                            
                            # Add in a value to the end of each list to maintain list length so as not to lose the last row of other data
                            # for pellet_count this is a duplicate of preceding row, for retrieval_time this is np.nan
                            
                            retrieval_time.append(np.nan)
                            pellet_count_shifted.append((pellet_count[-1] - 1))

                            
                            # Create new lists that only include data from the lines where event == 'Poke'
                            time2 = []
                            session_type2 = []
                            event2 = []
                            left_poke2 = []
                            right_poke2 = []
                            pellet_count2 = []
                            retrieval_time2 = []
                            poke_time2 = []
                            
                            for a, b, c, d, e, f, g, h in zip(event, left_poke_shifted, right_poke_shifted, pellet_count_shifted, time, session_type, retrieval_time, poke_time):
                                if a != 'Pellet':
                                    event2.append(a)
                                    left_poke2.append(b)
                                    right_poke2.append(c) 
                                    pellet_count2.append(d)
                                    time2.append(e)
                                    session_type2.append(f)
                                    retrieval_time2.append(g)
                                    poke_time2.append(h)
                        
                        # create list for pellet count that only included those with recorded retrieval time
                        
                        timed_pellet_count = []
                        
                        counter = 0
                        
                        for i in range(0, len(pellet_count2)):
                            if retrieval_time2[i] == 'Timed_out':
                                timed_pellet_count.append(counter)
                            elif retrieval_time2[i] != 'Timed_out':
                                counter += 1
                                timed_pellet_count.append(counter)
                        
                        # Change the time column from strings to datetime format for calculating durations between timestamps and creating time bins
                        
                        time2 = [dt.datetime.strptime(time, '%m/%d/%Y %H:%M:%S') for time in time2]
                        
                        # Create total_poke column
                
                        total_pokes = []
                        
                        for i in range(0, len(left_poke2)):
                            total_pokes.append(left_poke2[i] + right_poke2[i])
                        
                        # Create two new columns that show the percentage of pokes that are left or right
                        
                        left_percent = []
                        right_percent = []
                        
                        for i in range(0, len(left_poke2)):
                            left_percent.append(left_poke2[i] / total_pokes[i] * 100)
                            right_percent.append(right_poke2[i] / total_pokes[i] * 100)
                                        
                        # Calculate how much time (in seconds) has elapsed from session start time for each event (nose poke)
                        
                        seconds_elapsed = []
                        
                        for i in range(0, len(time2)):
                            time_from_start = time2[i] - session_start
                            result = int(time_from_start.total_seconds())
                            seconds_elapsed.append(result)
                        
                        # Create binary poke columns
            
                        left_poke_binary = []
    
                        if left_poke2[0] == 1:
                            left_poke_binary.append(1)
                        else:
                            left_poke_binary.append(0)
                        
                        for i in range(1, len(left_poke2)):
                            if left_poke2[i - 1] != left_poke2[i]:
                                left_poke_binary.append(1)
                            else:
                                left_poke_binary.append(0)
                        
                        right_poke_binary = []
                            
                        if right_poke2[0] == 1:
                            right_poke_binary.append(1)
                        else:
                            right_poke_binary.append(0)
                        
                        for i in range(1, len(right_poke2)):
                            if right_poke2[i - 1] != right_poke2[i]:
                                right_poke_binary.append(1)
                            else:
                                right_poke_binary.append(0)    
                        
                        
                        
                        # Create time bins of desired length (input for desired length is at the top of the code)
                        
                        if seconds_in_bins != '':
                        
                            end_time = seconds_elapsed[-1]
                            
                            import math
                            
                            # Create end value that is the next greatest multiple of the required time bin duration greater than the end_time so that those data points are retained in the output
                            
                            excess = math.ceil(end_time / int(seconds_in_bins)) # Rounds up so that the number of bins is the multiple of bin length greater than the time point
                            
                            end_bin = (int(session_duration_mins) * 60)
                            
                            interval_range = pd.interval_range(start=0, freq=int(seconds_in_bins), end=end_bin, closed="left") #'left' means that it includes the first data point which is 0 because it's start time
                            
                            time_bins = df[seconds_elapsed] = pd.cut(seconds_elapsed, interval_range, include_lowest=True, ordered=True)

                            # Create dictionary of time bins as keys with bin number as matching entry to label the bins
                            
                            # Create a list of integers of the same length as there are time bins
                            
                            bin_number = []
                            a = 1
                            for i in range(0, len(interval_range)):
                                bin_number.append(a)
                                a += 1
                            
                            make_dictionary = zip(interval_range, bin_number)
                            
                            bin_dictionary = dict(make_dictionary)
                            
                            bin_num = []
                            for i in range(0, len(time_bins)):
                                bin_num.append(bin_dictionary.get((time_bins[i])))
                                
                            # excess rows to delete...
                            
                            to_keep = []

                            for i in range(0, len(seconds_elapsed)):
                                if seconds_elapsed[i] < int(session_duration_mins) * 60:
                                    to_keep.append(seconds_elapsed[i])
                                    
                            if len(bin_num) > len(to_keep):
                                    del bin_num[len(to_keep):]
                                    # del time_bins[len(to_keep):]
                                    del time2[len(to_keep):]
                                    del session_type2[len(to_keep):]
                                    del event2[len(to_keep):]
                                    del left_poke2[len(to_keep):]
                                    del right_poke2[len(to_keep):]
                                    del pellet_count2[len(to_keep):]
                                    del retrieval_time2[len(to_keep):]
                                    del poke_time2[len(to_keep):]
                                    del timed_pellet_count[len(to_keep):]
                                    del total_pokes[len(to_keep):]
                                    del left_percent[len(to_keep):]
                                    del right_percent[len(to_keep):]
                                    del seconds_elapsed[len(to_keep):]
                                    del left_poke_binary[len(to_keep):]
                                    del right_poke_binary[len(to_keep):]

                        # Create chronological timing data
            
                        #####-----##### Chronological Poke Time Data #####-----#####
                        
                        l_poke_time = [] # poke time for all left pokes
                        r_poke_time = [] # poke time for all right pokes
                        
                        l_poke_time_chron = [] # poke time for all left pokes with nan if it was a right poke to maintain array length the same as all pokes
                        r_poke_time_chron = [] # poke time for all right pokes with nan if it was a left poke to maintain array length the same as all pokes
                        
                        for i in range(0, len(poke_time2)): # Collates the poke_time by side (regardless of port status)
                           if event2[i] == 'Left':
                               l_poke_time.append(poke_time2[i])
                               l_poke_time_chron.append(poke_time2[i])
                               r_poke_time_chron.append(np.nan)
                           else:
                               r_poke_time.append(poke_time2[i])
                               r_poke_time_chron.append(poke_time2[i])
                               l_poke_time_chron.append(np.nan)

                        
                        if seconds_in_bins != '':


                            # Get the last entry into each bin for the rest of the columns required
                            
                            bin_num_binned = []
                            left_binned = []
                            right_binned = []
                            total_pokes_binned = []
                            pellet_binned = []
                            session_type_binned = []
                            left_percent_binned = []
                            right_percent_binned = []
                            
                            timed_pellet_binned = []

                            # time binned
                            for i in range(1, len(to_keep)):
                                    if bin_num[i - 1] != bin_num[i]:
                                        bin_num_binned.append(bin_num[i - 1])
                            bin_num_binned.append(bin_num[i - 0])
                            
                            # left binned
                            for i in range(1, len(left_poke2)):
                                    if time_bins[i - 1] != time_bins[i]:
                                        left_binned.append(left_poke2[i - 1])
                            left_binned.append(left_poke2[i - 0])
                                    
                            # right binned
                            for i in range(1, len(right_poke2)):
                                    if time_bins[i - 1] != time_bins[i]:
                                        right_binned.append(right_poke2[i - 1])
                            right_binned.append(right_poke2[i - 0])
                            
                            # total binned
                            for i in range(1, len(total_pokes)):
                                    if time_bins[i - 1] != time_bins[i]:
                                        total_pokes_binned.append(total_pokes[i - 1])
                            total_pokes_binned.append(total_pokes[i - 0])
                                 
                            # pellet binned
                            for i in range(1, len(pellet_count2)):
                                    if time_bins[i - 1] != time_bins[i]:
                                        pellet_binned.append(pellet_count2[i - 1])
                            pellet_binned.append(pellet_count2[i - 0])
                            
                            # session type binned
                            for i in range(1, len(session_type2)):
                                    if time_bins[i - 1] != time_bins[i]:
                                        session_type_binned.append(session_type2[i - 1])
                            session_type_binned.append(session_type2[i - 0])
                            
                            # left and right percent binned
                            for i in range(0, len(total_pokes_binned)):
                                left_percent_binned.append(left_binned[i] / total_pokes_binned[i] * 100)
                                right_percent_binned.append(right_binned[i] / total_pokes_binned[i] * 100)
                            
                            # timed pellet binned
                            for i in range(1, len(timed_pellet_count)):
                                    if time_bins[i - 1] != time_bins[i]:
                                        timed_pellet_binned.append(timed_pellet_count[i - 1])
                            timed_pellet_binned.append(timed_pellet_count[i - 0])

                            # Create mean poke and retrieval time columns for blocks
            
                            block_sum_all_poke_time = [] # cumulative sum of all poke times
                            block_sum_l_poke_time = [] # cumulative sum of active poke times
                            block_sum_r_poke_time = [] # cumulative sum of inactive poke times
                            block_mean_all_poke_time = [] # cumulative mean of all poke times
                            block_mean_l_poke_time = [] # cumulative mean of active poke times
                            block_mean_r_poke_time = [] # cumulative mean of inactive poke times
                            
                            bin_counter = 1
                            bin_index = 0

                            while bin_num[0] != bin_counter: # fills in any empty leading bins until it gets to the bin with the first data point
                                    print('hello', bin_counter)
                                    bin_num_binned.insert(bin_counter - 1, bin_counter)
                                    left_binned.insert(bin_counter - 1, 0)
                                    right_binned.insert(bin_counter - 1, 0)
                                    total_pokes_binned.insert(bin_counter - 1, 0)
                                    pellet_binned.insert(bin_counter - 1, 0)
                                    session_type_binned.insert(bin_counter - 1, session_type2[0])
                                    left_percent_binned.insert(bin_counter - 1, np.nan)
                                    right_percent_binned.insert(bin_counter - 1, np.nan)
                                    timed_pellet_binned.insert(bin_counter - 1, 0)
                                    bin_counter += 1
                                    bin_index += 1

                            sum_all_poke_time = 0
                            sum_l_poke_time = 0
                            sum_r_poke_time = 0
                            index = 1
                            comp_block_index = 1
                            l_poke_counter = 0
                            r_poke_counter = 0
                            max_bins = (int(session_duration_mins) / (int(seconds_in_bins) / 60))

                            # if seconds_elapsed[0] > int(seconds_in_bins) * index:
                            while bin_num[0] > index: # if the first time bin is empty (might need to change this to while rather than if for any cases where first and following bins are empty...?)
                                # print('yo mumma ', bin_num[0], index)
                                block_sum_all_poke_time.append(0)
                                block_sum_l_poke_time.append(0)
                                block_sum_r_poke_time.append(0)
                                block_mean_all_poke_time.append(0)
                                block_mean_l_poke_time.append(0)
                                block_mean_r_poke_time.append(0)
                                
                                index += 1

                            # if seconds_elapsed[-1] > int(seconds_in_bins):
                            if bin_num[-1] > 1: # if the last data point is not in the first time bin
                            
                                for i in range(0, len(bin_num)):
                                    
                                    # if int(seconds_elapsed[i]) <= int(seconds_in_bins) * index:
                                    if bin_num[i] == index:
                                        sum_all_poke_time += poke_time2[i]
                                        if left_poke_binary[i] == 1:
                                            sum_l_poke_time += poke_time2[i]
                                            l_poke_counter += 1
                                        elif right_poke_binary[i] == 1:
                                            sum_r_poke_time += poke_time2[i]
                                            r_poke_counter += 1
                                        
                                    # elif int(seconds_elapsed[i]) >= int(seconds_in_bins) * index:
                                    elif bin_num[i] > index:
    
                                        block_sum_all_poke_time.append(sum_all_poke_time)
                                        block_sum_l_poke_time.append(sum_l_poke_time)
                                        block_sum_r_poke_time.append(sum_r_poke_time)
                                        if sum_all_poke_time != 0:
                                            block_mean_all_poke_time.append((sum_all_poke_time / (l_poke_counter + r_poke_counter)))
                                        else:
                                            block_mean_all_poke_time.append('N/A')
                                        if sum_l_poke_time != 0:
                                            block_mean_l_poke_time.append((sum_l_poke_time / l_poke_counter))
                                        else:
                                            block_mean_l_poke_time.append('N/A')
                                        if sum_r_poke_time != 0:
                                            block_mean_r_poke_time.append((sum_r_poke_time / r_poke_counter))
                                        else:
                                            block_mean_r_poke_time.append('N/A')
                                        
                                        index += 1
                                        comp_block_index += 1
                                    
                                        sum_all_poke_time += poke_time2[i]
                                        if left_poke_binary[i] == 1:
                                            sum_l_poke_time += poke_time2[i]
                                            l_poke_counter += 1
                                        elif right_poke_binary[i] == 1:
                                            sum_r_poke_time += poke_time2[i]
                                            r_poke_counter += 1
                                        # print('i', i, 
                                        #       ',  index', index, 
                                        #       ',  bin_num[i]', bin_num[i], 
                                        #       ', bin_num[i + 1]', bin_num[i + 1], 
                                        #       ',  length bin_num', len(bin_num))
                                                                               
                                        if i != (len(bin_num) - 1):
                                            # print('WOWSERS', (bin_num_binned[comp_block_index - 1]))
                                            if bin_num[i] == bin_num_binned[comp_block_index - 1] and bin_num[i + 1] > bin_num_binned[comp_block_index - 1]: # if there is only 1 poke in the bin need to add the data to the lists otherwise it just gets included in the following block
                                            # if bin_num[i] == (bin_num_binned[comp_block_index - 1]) and bin_num[i + 1] > (comp_block_index - 1): # if there is only 1 poke in the bin need to add the data to the lists otherwise it just gets included in the following block
                                                # print('IM SO LONELY BY MYSELF IN THIS BIN')
                                                block_sum_all_poke_time.append(sum_all_poke_time)
                                                block_sum_l_poke_time.append(sum_l_poke_time)
                                                block_sum_r_poke_time.append(sum_r_poke_time)
                                                if sum_all_poke_time != 0:
                                                    block_mean_all_poke_time.append((sum_all_poke_time / (l_poke_counter + r_poke_counter)))
                                                else:
                                                    block_mean_all_poke_time.append('N/A')
                                                if sum_l_poke_time != 0:
                                                    block_mean_l_poke_time.append((sum_l_poke_time / l_poke_counter))
                                                else:
                                                    block_mean_l_poke_time.append('N/A')
                                                if sum_r_poke_time != 0:
                                                    block_mean_r_poke_time.append((sum_r_poke_time / r_poke_counter))
                                                else:
                                                    block_mean_r_poke_time.append('N/A')
                                                    
                                                index += 1
                                        
                                            while bin_num[i + 1] > index: # if the next block is empty need to increase the index to match the bin count so that it doesn't just put each new entry into the lists as it's greater than the corresponding bin number
                                                index += 1
                                        

                                if int(seconds_elapsed[-1]) <= int(session_duration_mins) * 60: #triggers entry of the last block if it hasn't exceeded the session length
                                    # print('Last POKE TIME bin added')    
                                    block_sum_all_poke_time.append(sum_all_poke_time)
                                    block_sum_l_poke_time.append(sum_l_poke_time)
                                    block_sum_r_poke_time.append(sum_r_poke_time)
                                    if sum_all_poke_time != 0:
                                        block_mean_all_poke_time.append((sum_all_poke_time / (l_poke_counter + r_poke_counter)))
                                    else:
                                        block_mean_all_poke_time.append('N/A')
                                    if sum_l_poke_time != 0:
                                        block_mean_l_poke_time.append((sum_l_poke_time / l_poke_counter))
                                    else:
                                        block_mean_l_poke_time.append('N/A')
                                    if sum_r_poke_time != 0:
                                        block_mean_r_poke_time.append((sum_r_poke_time / r_poke_counter))
                                    else:
                                        block_mean_r_poke_time.append('N/A')

                            else: # if there is only data in the first time bin need to trigger it getting added to the lists
                                for i in range(0, len(poke_time2)):
                                    
                                    if int(seconds_elapsed[i]) <= int(seconds_in_bins) * index:
                                        sum_all_poke_time += poke_time2[i]
                                        if left_poke_binary[i] == 1:
                                            sum_l_poke_time += poke_time2[i]
                                            l_poke_counter += 1
                                        elif right_poke_binary[i] == 1:
                                            sum_r_poke_time += poke_time2[i]
                                            r_poke_counter += 1
    
                                block_sum_all_poke_time.append(sum_all_poke_time)
                                block_sum_l_poke_time.append(sum_l_poke_time)
                                block_sum_r_poke_time.append(sum_r_poke_time)
                                block_mean_all_poke_time.append((sum_all_poke_time / (l_poke_counter + r_poke_counter)))
                                block_mean_l_poke_time.append((sum_l_poke_time / l_poke_counter))
                                block_mean_r_poke_time.append((sum_r_poke_time / r_poke_counter))
                                
                                index += 1
                            
                            block_sum_all_pellet_retrieval_time = [] # cumulative sum of all pellet retrieval times
                            block_mean_all_pellet_retrieval_time = [] # cumulative mean of all pellet retrieval times
                            
                            block_sum_timed_pellet_retrieval_time = []
                            block_mean_timed_pellet_retrieval_time = []
                                                        
                            sum_all_retrieval_time = 0
                            sum_timed_retrieval_time = 0
                            timed_pellet_counter = 0
                            index = 1
                            comp_block_index = 1
                            
                            retrieval_time3 = []

                            for i in range(0, len(retrieval_time2)):
                                if retrieval_time2[i] == 'Timed_out':
                                    retrieval_time3.append(0)
                                else:
                                    retrieval_time3.append(float(retrieval_time2[i]))

                            while bin_num[0] > index: # if the first time bin is empty (might need to change this to while rather than if for any cases where first and following bins are empty...?)
                                # print('yo puppa ', bin_num[0], index)
                                block_sum_all_pellet_retrieval_time.append(0)
                                block_sum_timed_pellet_retrieval_time.append(0)
                                block_mean_all_pellet_retrieval_time.append(0)
                                block_mean_timed_pellet_retrieval_time.append(0)
                                
                                index += 1
                                comp_block_index += 1


                            # if seconds_elapsed[-1] > int(seconds_in_bins):
                            if bin_num[-1] > index:
                                for i in range(0, len(retrieval_time2)):
                                    # if int(seconds_elapsed[i]) <= int(seconds_in_bins) * index:
                                    if bin_num[i] == index:
                                        # print(str(seconds_elapsed[i]) + ' part of block ' + str(index))
                                        sum_all_retrieval_time += retrieval_time3[i]
                                        if retrieval_time3[i] != 0:
                                            sum_timed_retrieval_time += retrieval_time3[i]
                                            timed_pellet_counter += 1
                                                
                                    else:
                                        # print(str(seconds_elapsed[i]) + ' start of block ' + (str(index + 1)))
                                        if sum_all_retrieval_time != 0:
                                            # print(index, seconds_elapsed[i], (int(seconds_in_bins) * index), pellet_count2[i])
                                            block_sum_all_pellet_retrieval_time.append(sum_all_retrieval_time)
                                            block_mean_all_pellet_retrieval_time.append(sum_all_retrieval_time / total_pokes_binned[comp_block_index - 1])
                                        else:
                                            block_sum_all_pellet_retrieval_time.append(np.nan)
                                            block_mean_all_pellet_retrieval_time.append(np.nan)
                                        
                                        if sum_timed_retrieval_time != 0:
                                            block_sum_timed_pellet_retrieval_time.append(sum_timed_retrieval_time)
                                        else:
                                            block_sum_timed_pellet_retrieval_time.append(np.nan)
                                            
                                        if timed_pellet_counter != 0:
                                            block_mean_timed_pellet_retrieval_time.append(sum_timed_retrieval_time / timed_pellet_counter)
                                        else:
                                            block_mean_timed_pellet_retrieval_time.append(np.nan)
                                        
                                        index += 1 
                                        comp_block_index += 1
                                        
                                        sum_all_retrieval_time += retrieval_time3[i]
                                        if retrieval_time3[i] != 0:
                                            sum_timed_retrieval_time += retrieval_time3[i]
                                            timed_pellet_counter += 1
                                            
                                        if i != (len(bin_num) - 1):

                                            if bin_num[i] == bin_num_binned[comp_block_index - 1] and bin_num[i + 1] > bin_num_binned[comp_block_index - 1]: # if there is only 1 poke in the bin need to add the data to the lists otherwise it just gets included in the following block
                                            # if bin_num[i] == (bin_num_binned[comp_block_index - 1]) and bin_num[i + 1] > comp_block_index: # if there is only 1 poke in the bin need to add the data to the lists otherwise it just gets included in the following block
                                                if sum_all_retrieval_time != 0:
                                                    block_sum_all_pellet_retrieval_time.append(sum_all_retrieval_time)
                                                    block_mean_all_pellet_retrieval_time.append(sum_all_retrieval_time / total_pokes_binned[comp_block_index - 1])
                                                else:
                                                    block_sum_all_pellet_retrieval_time.append(np.nan)
                                                    block_mean_all_pellet_retrieval_time.append(np.nan)
                                                
                                                if sum_timed_retrieval_time != 0:
                                                    block_sum_timed_pellet_retrieval_time.append(sum_timed_retrieval_time)
                                                else:
                                                    block_sum_timed_pellet_retrieval_time.append(np.nan)
                                                    
                                                if timed_pellet_counter != 0:
                                                    block_mean_timed_pellet_retrieval_time.append(sum_timed_retrieval_time / timed_pellet_counter)
                                                else:
                                                    block_mean_timed_pellet_retrieval_time.append(np.nan)
                                                
                                                index += 1 
                                                comp_block_index += 1
                                        
                                            while bin_num[i + 1] > index:
                                                index += 1

                                if int(seconds_elapsed[-1]) <= int(session_duration_mins) * 60: # triggers adding of last bin if last time point hasn't exceeded session length
                                    block_sum_all_pellet_retrieval_time.append(sum_all_retrieval_time)
                                    block_mean_all_pellet_retrieval_time.append(sum_all_retrieval_time / total_pokes_binned[-1])
                                    
                                    block_sum_timed_pellet_retrieval_time.append(sum_timed_retrieval_time)
                                    if timed_pellet_counter != 0:
                                        block_mean_timed_pellet_retrieval_time.append(sum_timed_retrieval_time / timed_pellet_counter)
                                    else:
                                        block_mean_timed_pellet_retrieval_time.append(np.nan)

                            else:
                                for i in range(0, len(retrieval_time2)):
                                    if int(seconds_elapsed[i]) <= int(seconds_in_bins) * index:
                                        sum_all_retrieval_time += retrieval_time3[i]
                                        if retrieval_time3[i] != 0:
                                            sum_timed_retrieval_time += retrieval_time3[i]
                                            timed_pellet_counter += 1
                                
                                block_sum_all_pellet_retrieval_time.append(sum_all_retrieval_time)
                                block_mean_all_pellet_retrieval_time.append(sum_all_retrieval_time / total_pokes_binned[index - 1])
                                
                                block_sum_timed_pellet_retrieval_time.append(sum_timed_retrieval_time)
                                if timed_pellet_counter != 0:
                                    block_mean_timed_pellet_retrieval_time.append(sum_timed_retrieval_time / timed_pellet_counter)
                                else:
                                    block_mean_timed_pellet_retrieval_time.append('N/A')
                                        
                                index += 1   

                            # Enter new row for any bins that have no data in them (for cumulative bins this is a duplication of the preceding row)

                            session_type3 = session_type2[0]
    
                            for i in bin_dictionary:
                                if bin_dictionary[i] in bin_num_binned:
                                    continue
                                else:
                                    bin_num_binned.insert((bin_dictionary[i] - 1), bin_dictionary[i])
                                    left_binned.insert((bin_dictionary[i] - 1), left_binned[(bin_dictionary[i] - 2)])
                                    right_binned.insert((bin_dictionary[i] - 1), right_binned[(bin_dictionary[i] - 2)])
                                    total_pokes_binned.insert((bin_dictionary[i] - 1), total_pokes_binned[(bin_dictionary[i] - 2)])
                                    pellet_binned.insert((bin_dictionary[i] - 1), pellet_binned[(bin_dictionary[i] - 2)])
                                    session_type_binned.insert((bin_dictionary[i] - 1), session_type3)
                                    left_percent_binned.insert((bin_dictionary[i] - 1), left_percent_binned[(bin_dictionary[i] - 2)])
                                    right_percent_binned.insert((bin_dictionary[i] - 1), right_percent_binned[(bin_dictionary[i] - 2)])
                                    timed_pellet_binned.insert((bin_dictionary[i] - 1), timed_pellet_binned[(bin_dictionary[i] - 2)])
                                    block_sum_all_poke_time.insert((bin_dictionary[i] - 1), block_sum_all_poke_time[(bin_dictionary[i] - 2)])
                                    block_sum_l_poke_time.insert((bin_dictionary[i] - 1), block_sum_l_poke_time[(bin_dictionary[i] - 2)])
                                    block_sum_r_poke_time.insert((bin_dictionary[i] - 1), block_sum_r_poke_time[(bin_dictionary[i] - 2)])
                                    block_mean_all_poke_time.insert((bin_dictionary[i] - 1), block_mean_all_poke_time[(bin_dictionary[i] - 2)])
                                    block_mean_l_poke_time.insert((bin_dictionary[i] - 1), block_mean_l_poke_time[(bin_dictionary[i] - 2)])
                                    block_mean_r_poke_time.insert((bin_dictionary[i] - 1), block_mean_r_poke_time[(bin_dictionary[i] - 2)])
                                    block_sum_all_pellet_retrieval_time.insert((bin_dictionary[i] - 1), block_sum_all_pellet_retrieval_time[(bin_dictionary[i] - 2)])
                                    block_mean_all_pellet_retrieval_time.insert((bin_dictionary[i] - 1), block_mean_all_pellet_retrieval_time[(bin_dictionary[i] - 2)])
                                    block_sum_timed_pellet_retrieval_time.insert((bin_dictionary[i] - 1), block_sum_timed_pellet_retrieval_time[(bin_dictionary[i] - 2)])
                                    block_mean_timed_pellet_retrieval_time.insert((bin_dictionary[i] - 1), block_mean_timed_pellet_retrieval_time[(bin_dictionary[i] - 2)])

                            if len(bin_num_binned) > num_of_bins:
                                
                                del bin_num_binned[int(num_of_bins):]
                                del left_binned[int(num_of_bins):]
                                del right_binned[int(num_of_bins):]
                                del total_pokes_binned[int(num_of_bins):]
                                del pellet_binned[int(num_of_bins):]
                                del session_type_binned[int(num_of_bins):]
                                del left_percent_binned[int(num_of_bins):]
                                del right_percent_binned[int(num_of_bins):]
                                del timed_pellet_binned[int(num_of_bins):]
                                del block_sum_all_poke_time[int(num_of_bins):]
                                del block_sum_l_poke_time[int(num_of_bins):]
                                del block_sum_r_poke_time[int(num_of_bins):]
                                del block_mean_all_poke_time[int(num_of_bins):]
                                del block_mean_l_poke_time[int(num_of_bins):]
                                del block_mean_r_poke_time[int(num_of_bins):]
                                del block_sum_all_pellet_retrieval_time[int(num_of_bins):]
                                del block_mean_all_pellet_retrieval_time[int(num_of_bins):]
                                del block_sum_timed_pellet_retrieval_time[int(num_of_bins):]
                                del block_mean_timed_pellet_retrieval_time[int(num_of_bins):]
    
                            # Make the counts within the bins rather than cumulative
                            
                            left_binned_within = []
                            right_binned_within = []
                            total_pokes_binned_within = []
                            pellet_binned_within = []
                            left_percent_binned_within = []
                            right_percent_binned_within = []
                            
                            timed_pellet_binned_within = []
                            
                            left_binned_within.append(left_binned[0])
                            for i in range(1, len(left_binned)):
                                left_binned_within.append(left_binned[i] - left_binned[i - 1])
                            
                            right_binned_within.append(right_binned[0])
                            for i in range(1, len(right_binned)):
                                right_binned_within.append(right_binned[i] - right_binned[i - 1])
                            
                            total_pokes_binned_within.append(total_pokes_binned[0])
                            for i in range(1, len(total_pokes_binned)):
                                total_pokes_binned_within.append(total_pokes_binned[i] - total_pokes_binned[i - 1])
                            
                            pellet_binned_within.append(pellet_binned[0])
                            for i in range(1, len(pellet_binned)):
                                pellet_binned_within.append(pellet_binned[i] - pellet_binned[i - 1])
                                
                            for i in range(0, len(total_pokes_binned_within)):
                                if left_binned_within[i] + right_binned_within[i] != 0:
                                    left_percent_binned_within.append(left_binned_within[i] / total_pokes_binned_within[i] * 100)
                                    right_percent_binned_within.append(right_binned_within[i] / total_pokes_binned_within[i] * 100)
                                else:
                                    left_percent_binned_within.append(np.nan)
                                    right_percent_binned_within.append(np.nan)
                            
                            timed_pellet_binned_within.append(timed_pellet_binned[0])
                            for i in range(1, len(timed_pellet_binned)):
                                timed_pellet_binned_within.append(timed_pellet_binned[i] - timed_pellet_binned[i - 1])
                                
    
                            block_within_sum_all_poke_time = [] # within block sum of all poke times
                            block_within_sum_l_poke_time = [] # within block sum of active poke times
                            block_within_sum_r_poke_time = [] # within block sum of inactive poke times
                            
                            block_within_sum_all_poke_time.append(block_sum_all_poke_time[0])
                            block_within_sum_l_poke_time.append(block_sum_l_poke_time[0])
                            block_within_sum_r_poke_time.append(block_sum_r_poke_time[0])  
                            # print(len(block_sum_all_poke_time))
                            for i in range(1, len(block_sum_all_poke_time)):
                                block_within_sum_all_poke_time.append((block_sum_all_poke_time[i] - block_sum_all_poke_time[i - 1]))
                                block_within_sum_l_poke_time.append((block_sum_l_poke_time[i] - block_sum_l_poke_time[i - 1]))
                                block_within_sum_r_poke_time.append((block_sum_r_poke_time[i] - block_sum_r_poke_time[i - 1]))  
                            
                            block_within_mean_all_poke_time = [] # within block mean of all poke times
                            block_within_mean_l_poke_time = [] # within block mean of active poke times
                            block_within_mean_r_poke_time = [] # within block mean of inactive poke times
                            # print(len(total_pokes_binned_within), len(block_within_sum_all_poke_time))
                            for i in range(0, len(block_within_sum_all_poke_time)):
                                
                                if total_pokes_binned_within[i] != 0:
                                    block_within_mean_all_poke_time.append((block_within_sum_all_poke_time[i] / total_pokes_binned_within[i]))
                                else:
                                    block_within_mean_all_poke_time.append(np.nan)
                                
                                if left_binned_within[i] != 0:
                                    block_within_mean_l_poke_time.append((block_within_sum_l_poke_time[i] / left_binned_within[i]))
                                else:
                                    block_within_mean_l_poke_time.append(np.nan)
                                
                                if right_binned_within[i] != 0:
                                    block_within_mean_r_poke_time.append((block_within_sum_r_poke_time[i] / right_binned_within[i]))
                                else:
                                    block_within_mean_r_poke_time.append(np.nan)
                            
                            block_within_sum_all_pellet_retrieval_time = [] # within block sum of pellet retrieval times
                            block_within_mean_all_pellet_retrieval_time = [] # within block mean of pellet retrieval times
                            
                            block_within_sum_timed_pellet_retrieval_time = []
                            block_within_mean_timed_pellet_retrieval_time = []
                            
                            block_within_sum_all_pellet_retrieval_time.append(block_sum_all_pellet_retrieval_time[0])
                            block_within_sum_timed_pellet_retrieval_time.append(block_sum_timed_pellet_retrieval_time[0])
                            for i in range(1, len(block_sum_all_pellet_retrieval_time)):
                                block_within_sum_all_pellet_retrieval_time.append(block_sum_all_pellet_retrieval_time[i] - block_sum_all_pellet_retrieval_time[i - 1])        
                                if block_sum_timed_pellet_retrieval_time[i] != np.nan:
                                    if block_sum_timed_pellet_retrieval_time[i - 1] != np.nan:
                                        block_within_sum_timed_pellet_retrieval_time.append(block_sum_timed_pellet_retrieval_time[i] - block_sum_timed_pellet_retrieval_time[i - 1])
                                    else:
                                        block_within_sum_timed_pellet_retrieval_time.append(np.nan)
    
                            for i in range(0, len(block_within_sum_all_pellet_retrieval_time)):
                                if total_pokes_binned_within[i] != 0:
                                    block_within_mean_all_pellet_retrieval_time.append(block_within_sum_all_pellet_retrieval_time[i] / total_pokes_binned_within[i])
                                else:
                                    block_within_mean_all_pellet_retrieval_time.append(np.nan)
                                
                                if timed_pellet_binned_within[i] != 0:
                                    block_within_mean_timed_pellet_retrieval_time.append(block_within_sum_timed_pellet_retrieval_time[i] / timed_pellet_binned_within[i])
                                else:
                                    block_within_mean_timed_pellet_retrieval_time.append(np.nan)
                           
                        #####----- Create session summary data-----#####
                        
                        task = session_type3
                    
                        session_hours = str(math.floor(seconds_elapsed[-1] / 3600))
                    
                        session_mins = math.floor((seconds_elapsed[-1] % 3600) / 60)
                        
                        session_secs = seconds_elapsed[-1] % 60
                        
                        if session_mins < 10:
                            mins = '0' + str(session_mins)
                        else:
                            mins = str(session_mins)
                            
                        if session_secs < 10:
                            secs = '0' + str(session_secs)
                        else:
                            secs = str(session_secs)
                            
                        session_duration = str(session_hours) + ':' + mins + ':' + secs
                        
                        date = import_name[7:13]
                        aus_date = date[2:4] + '/' + date[0:2] + '/20' + date[4:]
                        
                        mean_all_poke_time = block_sum_all_poke_time[-1] / total_pokes_binned[-1]
                        
                        if left_binned[-1] != 0:
                            mean_l_poke_time = block_sum_l_poke_time[-1] / left_binned[-1]
                        else:
                            mean_l_poke_time = 'N/A'
                            
                        if right_binned[-1] != 0:
                            mean_r_poke_time = block_sum_r_poke_time[-1] / right_binned[-1]
                        else:
                            mean_r_poke_time = 'N/A'
                        
                        if block_sum_all_pellet_retrieval_time[-1] != 0:
                            mean_all_pellet_retrieval_time = block_sum_all_pellet_retrieval_time[-1] / pellet_binned[-1]
                        else:
                            mean_all_pellet_retrieval_time = 'N/A'
                            
                        if timed_pellet_binned[-1]!= 0:
                            mean_timed_pellet_retrieval_time = block_sum_timed_pellet_retrieval_time[-1] / timed_pellet_binned[-1]
                        else:
                            mean_timed_pellet_retrieval_time = 'N/A'
                        
                        variable = ['Filename', 'Date', 'Task', 'Duration', '',
                                    'Total Pokes', 'Mean Poke Time', '',
                                    'Left Pokes', 'Mean Left Poke Time', '% Left Pokes', '',
                                    'Right Pokes', 'Mean Right Poke Time', '% Right Pokes', '',
                                    'Pellets', 'Mean ALL Pellet Retrieval Time', 'Timed Pellets', 'Mean TIMED Pellet Retrieval Time']
                        
                        value = [import_name.strip('.CSV'), aus_date, task, session_duration, '',
                                 total_pokes_binned[-1], mean_all_poke_time,'',
                                 left_binned[-1], mean_l_poke_time, left_percent_binned[-1],'',
                                 right_binned[-1], mean_r_poke_time, right_percent_binned[-1], '',
                                 pellet_binned[-1], mean_all_pellet_retrieval_time, timed_pellet_binned[-1], mean_timed_pellet_retrieval_time]
    
                        
                        # print(len(bin_num_binned), len(session_type_binned), len(left_binned), len(right_binned), len(total_pokes_binned))
                        # print(len(left_percent_binned), len(right_percent_binned), len(block_mean_l_poke_time), len(block_mean_r_poke_time), len(block_mean_all_poke_time))
                        # print(len(pellet_binned), len(block_mean_all_pellet_retrieval_time), len(timed_pellet_binned), len(block_mean_timed_pellet_retrieval_time))
                        # Export the data.
                        
                        #####-----##### add summary values to list for joining
                        
                        s_date.append(aus_date)
                        s_filename.append(filename)
                        s_totalpokes.append(total_pokes_binned[-1])
                        s_leftpokes.append(left_binned[-1])
                        s_leftpercent.append(left_percent_binned[-1])
                        s_rightpokes.append(right_binned[-1])
                        s_rightpercent.append(right_percent_binned[-1])
                        s_pellets.append(pellet_binned[-1])
                        
                        if export_results == 'Y':
                            # Always export Summary and Chronological Data
                            
                            results_summary = {'Variable': variable, 'Value': value}
                            export_file_summary = pd.DataFrame(results_summary, columns = ['Variable', 'Value'])
                            
                            results_chronological = {'Time (seconds)': seconds_elapsed, 'Session Type': session_type2, 
                                                     'Left Poke': left_poke2, 'Right Poke': right_poke2, 'Total Poke': total_pokes, '% Left Pokes': left_percent, '% Right Pokes': right_percent, 'Poke Time': poke_time2,
                                                     'Pellet Count': pellet_count2, 'Pellet Retrieval Time': retrieval_time2}
                            export_file_chronological = pd.DataFrame(results_chronological, columns = ['Time (seconds)', 'Session Type', 
                                                                                                       'Left Poke', 'Right Poke', 'Total Poke', '% Left Pokes', '% Right Pokes', 'Poke Time', 
                                                                                                       'Pellet Count', 'Pellet Retrieval Time'])
                            
                            
                            if seconds_in_bins != '':
                                results_binned_c = {'Time bin (' + str(seconds_in_bins) + 's each)': bin_num_binned, 'Session Type': session_type_binned, 
                                                    'Left Poke': left_binned, 'Right Poke': right_binned, 'Total Poke': total_pokes_binned, 
                                                    '% Left Pokes': left_percent_binned, '% Right Pokes': right_percent_binned, 
                                                    'Mean Left Poke Time': block_mean_l_poke_time, 'Mean Right Poke Time': block_mean_r_poke_time, 'Mean Poke Time': block_mean_all_poke_time,
                                                    'Pellet Count': pellet_binned, 'Mean ALL Retrieval Time': block_mean_all_pellet_retrieval_time, 'Timed Pellet Count': timed_pellet_binned, 'Mean TIMED Retrieval Time': block_mean_timed_pellet_retrieval_time}
                                export_file_binned_c = pd.DataFrame(results_binned_c, columns = ['Time bin (' + seconds_in_bins + 's each)', 'Session Type', 
                                                                                                 'Left Poke', 'Right Poke', 'Total Poke', 
                                                                                                 '% Left Pokes', '% Right Pokes', 
                                                                                                 'Mean Left Poke Time', 'Mean Right Poke Time', 'Mean Poke Time',
                                                                                                 'Pellet Count', 'Mean ALL Retrieval Time', 'Timed Pellet Count', 'Mean TIMED Retrieval Time'])
                                
                                
                                results_binned_w = {'Time bin (' + str(seconds_in_bins) + 's each)': bin_num_binned, 'Session Type': session_type_binned, 
                                                    'Left Poke': left_binned_within, 'Right Poke': right_binned_within, 'Total Poke': total_pokes_binned_within, 
                                                    '% Left Pokes': left_percent_binned_within, '% Right Pokes': right_percent_binned_within, 
                                                    'Mean Left Poke Time': block_within_mean_l_poke_time, 'Mean Right Poke Time': block_within_mean_r_poke_time, 'Mean Poke Time': block_within_mean_all_poke_time,
                                                    'Pellet Count': pellet_binned_within, 'Mean ALL Retrieval Time': block_within_mean_all_pellet_retrieval_time, 'Timed Pellet Count': timed_pellet_binned_within, 'Mean TIMED Retrieval Time': block_within_mean_timed_pellet_retrieval_time}
                                export_file_binned_w = pd.DataFrame(results_binned_w, columns = ['Time bin (' + seconds_in_bins + 's each)', 'Session Type', 
                                                                                                 'Left Poke', 'Right Poke', 'Total Poke', 
                                                                                                 '% Left Pokes', '% Right Pokes', 
                                                                                                 'Mean Left Poke Time', 'Mean Right Poke Time', 'Mean Poke Time',
                                                                                                 'Pellet Count', 'Mean ALL Retrieval Time', 'Timed Pellet Count', 'Mean TIMED Retrieval Time'])
                            
                            print('Complete')
                            
                            # Export to excel
                            
                            from openpyxl import Workbook
                        
                            wb = Workbook()
                            
                            ws1 = wb.active
                            ws1.title = 'Summary'
                            
                            ws2 = wb.create_sheet()
                            ws2.title = 'Chronological'
                            
                            results_to_export = [export_file_summary, export_file_chronological]
                            
                            if seconds_in_bins != '':
                                
                                ws3 = wb.create_sheet()
                                ws3.title ='Binned Cumulative'
                                
                                ws4 = wb.create_sheet()
                                ws4.title ='Binned Within'
                                
                                results_to_export.append(export_file_binned_c)
                                results_to_export.append(export_file_binned_w)
                            
                            sheets_to_export = wb.sheetnames
                            
                            with pd.ExcelWriter(export_destination) as writer:
                                
                                for i in range(len(sheets_to_export)):
                                    results_to_export[i].to_excel(writer, sheet_name=str(sheets_to_export[i]), engine='openpyxl', index=False, header=True)
                     

        ##########---------- Overview Sheets ----------##########
        if export_overview == 'Y':
            from openpyxl import Workbook
                    
            wb = Workbook()
            
            ws = wb.active
            ws.title = 'Summary Overview'
            
            value_column = 'Value'
            variable_column = 'Variable'
    
            value_summary = []
            session_num = []
            counter = 1

            for filename in sorted(os.listdir(os.path.join(export_location, folder))):
                
                if filename.endswith('.xlsx'):
                    
                    if 'Overview' not in filename:
                        print(filename)
                        
                        # if 'Overview' not in filename:
                
                        if counter == 1:
                            
                            export_name = filename
                            export_destination = export_location + folder + '/' + export_name
                            
                            df_overview = pd.read_excel(export_destination, sheet_name = 'Summary')
                            
                            df_overview.drop(columns='Value', inplace=True)
                            
                        export_name = filename
                        export_destination = export_location + folder + '/' + export_name
                        
                        name = 'Session ' + str(counter)
                        session_num.append(name)
                        
                        df = pd.read_excel(export_destination, sheet_name = 'Summary')
                        
                        values = df[value_column].tolist()
                        
                        df_overview.insert(counter, name, values)
                        
                        counter += 1
                        
            overview_name = folder + ' FR1 Both Overview.xlsx'
            overview_destination = export_location + folder + '/' + overview_name
            
            with pd.ExcelWriter(overview_destination) as writer:
                            
                df_overview.to_excel(writer, sheet_name='Overview', engine='openpyxl', index=False, header=True)
    
            cohort_overview_destination = cohort_export_location + overview_name
                    
            with pd.ExcelWriter(cohort_overview_destination) as writer:
                            
                df_overview.to_excel(writer, sheet_name='Overview', engine='openpyxl', index=False, header=True)
                
            print('Overview complete')
            
        #####-----##### JOIN SESSION SUMMARY VALUES #####-----#####
        
        results_joined = {'Date': s_date, 'Filename': s_filename, 'Total Pokes': s_totalpokes, 'Left Pokes': s_leftpokes, 'Left Percent':s_leftpercent, 'Right Pokes': s_rightpokes, 'Right Percent': s_rightpercent, 'Pellets': s_pellets}
        export_file_joined = pd.DataFrame(results_joined, columns = ['Date', 'Filename', 'Total Pokes', 'Left Pokes', 'Left Percent', 'Right Pokes', 'Right Percent', 'Pellets'])
            
        from openpyxl import Workbook
                        
        wb = Workbook()
        
        ws1 = wb.active
        ws1.title = 'Summary Joined'
        
        sheets_to_export = wb.sheetnames
                        
        results_to_export = [export_file_joined]
        
        joined_name = folder + ' Summary Joined.xlsx'
        joined_destination = export_location + folder + '/' + joined_name
        joined_cohort_destination = cohort_export_location + joined_name
                    
        with pd.ExcelWriter(joined_destination) as writer:
                        
            for i in range(len(sheets_to_export)):
                results_to_export[i].to_excel(writer, sheet_name=str(sheets_to_export[i]), engine='openpyxl', index=False, header=True)
                
        with pd.ExcelWriter(joined_cohort_destination) as writer:
                        
            for i in range(len(sheets_to_export)):
                results_to_export[i].to_excel(writer, sheet_name=str(sheets_to_export[i]), engine='openpyxl', index=False, header=True)
        
        print(folder, ' SESSION SUMMARIES JOINED')